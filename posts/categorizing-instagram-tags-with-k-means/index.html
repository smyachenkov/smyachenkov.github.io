<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Categorizing Instagram Tags with K-Means | Stanislav Myachenkov</title>
<meta name="keywords" content="machine learning, categorization, k-means, instagram">
<meta name="description" content="Choose a perfect tags for Instagram with machine learning.">
<meta name="author" content="">
<link rel="canonical" href="https://smyachenkov.com/posts/categorizing-instagram-tags-with-k-means/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css" integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.4dcb3c4f38462f66c6b6137227726f5543cb934cca9788f041c087e374491df2.js" integrity="sha256-Tcs8TzhGL2bGthNyJ3JvVUPLk0zKl4jwQcCH43RJHfI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://smyachenkov.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://smyachenkov.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://smyachenkov.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://smyachenkov.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://smyachenkov.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-136218929-1', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="Categorizing Instagram Tags with K-Means" />
<meta property="og:description" content="Choose a perfect tags for Instagram with machine learning." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://smyachenkov.com/posts/categorizing-instagram-tags-with-k-means/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-24T00:00:00&#43;03:00" />
<meta property="article:modified_time" content="2019-03-24T00:00:00&#43;03:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Categorizing Instagram Tags with K-Means"/>
<meta name="twitter:description" content="Choose a perfect tags for Instagram with machine learning."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://smyachenkov.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Categorizing Instagram Tags with K-Means",
      "item": "https://smyachenkov.com/posts/categorizing-instagram-tags-with-k-means/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Categorizing Instagram Tags with K-Means",
  "name": "Categorizing Instagram Tags with K-Means",
  "description": "Choose a perfect tags for Instagram with machine learning.",
  "keywords": [
    "machine learning", "categorization", "k-means", "instagram"
  ],
  "articleBody": "Over the last couple of years Instagram, Facebook and many other social media have gotten rid of the chronological order in their post feed. While frustrating at first, this decision encouraged one part of social media that I like most of all: your content can be seen, discovered and rated not only by your friends and followers, but also by many other new people. To make your content discoverable you can use features such as hashtags, geolocations, tagging other people and so on.\nIn this article I will show you how to choose hashtags for your posts using machine learning to make it searchable for as many people interested in similar posts as possible. To solve this problem I will try to separate a dataset of Instagram hashtags from different users by their categories, so we can always have a good selection of hashtags on our hands. Ideally we will end up with a set of categories specific enough to fit your particular post, for example, about minimalistic architecture photography in Morocco or skydiving in New Zealand.\nPerfect tag In order to choose effective hashtags you have to balance two things.\nFirst, your tags should not be overused, because otherwise your may easily get lost in millions of other posts. For example, hashtags such as #travel with 380m posts and #photooftheday with 644m at the moment are simply too popular making it quite hard to compete for the top places\nSecond, your tags must be popular enough in their category; there must be people who watch and update them with new posts daily. Let’s say, our lowest boundary for tag popularity will be 100k posts and the highest will be 10m. Those numbers are purely objective: I got them from my friends who are active Instagram users. The data may be not perfect, but it’s good enough for the first iteration.\nIn addition to all that numeric criteria, your tag must be related to your post and your post category, simply because users want to discover related content.\nTo keep it short, our perfect tag must:\n• Be specific enough\n• Have between 100k and 10m posts\n• Belong to some group(s)\nOur Goal We are going to implement a categorization system, that will take tags like #building, #skyscaper, #architectureloversand #architecturepornand put them in a category that we will later call Architecture, or put tags like #pizza, #pastaand #italyin another category that can be called Italian Food.\nTo accomplish this, we are going to to collect a large number of Instagram posts, extract tags from them, and divide those tags into categories. You may ask, where are we going to find a list of the categories? Here’s the beauty of machine learning algorithms: we don’t know right now and that’s fine! However, using a few techniques and algorithms, we can separate a huge number of tags into small groups.\nThat’s is how Unsupervised Learning works.\nIn machine learning there are two huge areas: supervised learning and unsupervised learning. The main goal of supervised machine learning is to determine if new data belongs to one of the already known groups, while unsupervised learning separates data into new categories, that were unknown before.\nWe will be using one of the most popular unsupervised machine learning algorithms — k-means.\nDataset Our dataset consist of sets of hashtags, one for each instagram post. A single post may contain from 0 to 30 hashtags.\nHere’s the distribution of tags in my dataset:\nFrom this data, we can already make some quick assumptions. The two most popular numbers of hashtags are 1 and 30. It means that there are two broad categories of users: the first category assigns one meaningfull tag without spending lots of time on choosing more popular tags, and the other milks the hashtag machine for every possible opportunity :)\nPosts without any tags are excluded from this dataset because they don’t provide anything for our task.\nWe don’t need any other information from posts except their tags: we don’t care about the author, location or number of likes. Our input data will be a list of arrays of tags, where each line represents one single post:\n. . . {artofvisual,instamoment,spain,photo,andalucia,instalike,igersspain} {artofvisual,photos,nature,andalucia,instamoment,pic,spain,seville} {picture,exposure,instalike,photoftheday,igers,spain,picoftheday} {instamoment,picoftheday,photoftheday,picture,exploreeverything,igers} {christmas,photoftheday,picoftheday,moment,pic,igers} {ramennoodles,ramen,vegan,veganfood,whatveganseat,berlin,japanese,weekend} {summer,frozenyogurt,oreo,mango,blueberry} {photography,see,love,pic,mountains,view,picture,mood,dream,day,nature,pictureoftheday} {autumn,tofu,instadaily,whatveganseat,lunch,vegan,pumpkin} {hamburger,manhattan,fries,vegan,downtown,vacation,nyc} {naturewalk,zipline,archery,sunset,cycling,hiking,kenya} {sunsetlover,sunset,lovephotography,mobilephotography,sunsetsky,mobileclick,visionofpictures} {flowers,shadow,simplicity,spring,minimalism,home,nature,sunny,weekend,tulips,morning,still,mood} . . . Measuring tf-idf for tags We are going to place our posts into a multi-dimensional space, where each dimension represents one hashtag. It will be a very sparse space, because each post contains maximum of 30 tags, which means there will be 30 non-zero coordinate values, while all other coordinates, a couple of thousand of them, will be zero.\nAt this point, let’s do the whole process on a small sample dataset of 6 posts about Italian food and architecture:\n0: {italy,food} 1: {food,italy} 2: {food} 3: {italy,architecture} 4: {architecture,italy} 5: {architecture, } As you can see, this dataset has 3 unique hashtags: #italy, #food, and #architecture. That means we are going to be dealing with a 3-dimensional space.\nNow we need to put our posts into this 3-D tag space. We will calculate dimension values for every post using td-idf metric. This metric shows how important a word is in a document, in our case it measures the impact of a single tag for a post. It means that tags with very low or very high frequency will be assigned a lower rank.\nvectorizer = TfidfVectorizer() posts_coordinates = vectorizer.fit_transform(posts)\tprint(posts_coordinates)     0 1 2 3 4 5     architecture 0 0 0 0.75 0.75 1.0   food 0.75 0.75 1.0 0 0 0   italy 0.65 0.65 0 0.65 0.65 0    Posts 0 and 1 contain exactly the same set of tags, so they have exactly the same coordinates and they are placed in the same position in our tag space. Same goes for posts 3 and 4; the order of tags doesn’t matter.\nThis will be our data for following clustering with k-means.\nApplying K-Means K-Means is one of the most popular clustering algorithms and it’s pretty simple. The only decision you have to make is the number of clusters you want your data to be divided into — k number. The goal of this algorithm is to determine coordinates of k points, which will be the centers of mass for a cluster. Those points are also called centroids.\nThe algorithm has 3 steps:\n Initialize k cenrtoids with random coordinates Divide all training examples into k groups by choosing the nearest centroid Assign new centroid coordinates by calculating a center of mass for the groups from step 2  Steps 2 and 3 are repeated until the algorithm converges or reaches an optimal state. Results may depend a lot on randomly chosen initial centroid values, so calculcations can be run multiple times to get rid of random impact.\nLet’s see how it works on the example.\n In this image the gray squares are training examples and the colored circles are initial centroids. All the centroids are initialized with random coordinates, the training examples are not clustered.\n  Here all the training examples are assigned to the closest centroid and marked with the centroid’s color\n  Now we need to calculate new centroids for the groups created in step 2. This is achieved by calculating centers of mass for each training example belonging to a group\n  Clusterization by distance from newly created centroid is repeated and if we see that there are no more iterations required we can stop the algorithm and call this clusterization final\n  Now we are going to apply k-means clusterization to our dataset of posts about Italy. By looking at it, we can tell that there are 2 groups: food and architecture. So our k-parameter(the number of clusters we are going to divide our group into) will be 2.\nKMEANS_CLUSTERS = 2 ... model = KMeans(  n_clusters=KMEANS_CLUSTERS,  init='k-means++',  max_iter=5,  n_init=1,  verbose=True ) groups = model.fit_predict(data) groups is an array with the same size as the initial data array — 6. And it contains groups ids for entries in data in the same order:\npost 0: 0 post 1: 0 post 2: 0 post 3: 1 post 4: 1 post 5: 1 Our dataset was successfully divided into two groups: 0 — “food” and 1 — “architecture”.\nExtracting Tags For Categories Lets see where the centroids are located.\ncentroids = model.cluster_centers_ centroids are represented by a 2x3 matrix where each row contains the coordinates of a centroid in 3-dimensional space. Let’s add them to our plot.\n    architecture food italy     0 0 0.84 0.43   1 0.84 0 0.43    Our categories are located in the same 3-dimendional space as the posts from our training example. It means that each category has some numeric value that represents its relations to tags - coordinates. If we take absolute values of coordinates and sort them in ascending order - from highest to lowest - we can find tags with most impact on this particular category: it will be tags with lowest value, the closest to a category.\nFor instance, the most meaningful tag for our first centroid(on the right in the picture) is #architecture, and for the second centroid(on the left in the picture) it’s #food.\nImagine that we have many more tags, let’s say 10,000. We would not be interested in all 10,000 relations for each category, we would only want the most meaningful tags. So we will limit the top tags for each category by some number and only show those ones. This number will depend on how many clusters we choose.\nLet’s get back to our example. We are going to limit the number of tags in each category by two and pick the two most meaningful tags.\nTAGS_IN_CATEGORY = 2 ... ordered_centroids = model.cluster_centers_.argsort()[:, ::-1]\ttags = vectorizer.get_feature_names()  for idx, centroids in enumerate(ordered_centroids):  print(\"Centroid %s:\" % idx)  for centroid_tag in centroids[:TAGS_IN_CATEGORY]:  print(\"#%s\" % tags[centroid_tag]) This code separeates our tags into two categories:\nCentroid 0: #architecture #italy Centroid 1: #food #italy Here, tags in the category are ordered from the most relevant to the least. If we take some tags from the top of every category, we’ll get tags that can represent this category in a shorter way than listing all of them. Let’s call them leading tags. Like if we were to choose the one leading tag from our categories, we would get #architectureand #food.\nLet’s try this approach using a bigger sample. Imagine we have a classifier that produces tag categories with 20 tags, and one of the categories looks like this:\n#boat #water #sailing #ocean #lake #ship #river #boatlife #boats #port #island #sail #yacht #vacation #reflection #sailboat #fishing #bateau #relax #boating This group clearly combines tags related to boats and sailing. We can give it a human-readable name using its leading tags. Let’s say we want to have 3 leading tags, then they will be #boat, #waterand #sailing. In the next step, we will concatenate these tags into a single name so it will look like boat_water_sailing.\nWhile working on a large dataset, we will end up with a huge list of categories named like this one, or, for example, something like animal_animals_cat, goodmorning_coffee_morning or sushi_japanesefood_food. These human-readable names can help us quickly understand what this group is about and implement a groups catalogue, search or group suggestions.\nResult In this article we’ve explored a way of grouping Instagram tags from a set of Instagram posts into thematic categories.\nYou can find a working demo here: https://github.com/smyachenkov/k-means_tags_demo.\nI left behind some topics, for example, choosing k-means parameters like number of categories and number of tags in a single category. I will cover those topics in my upcoming posts.\nIn conclusion, I want to say that exploring new content can be very fun, and some categories have a huge amount of awesome content. You can use this knowledge to find interesting new people, find your unique style, place your content into the right category or be inspired by something new.\nKeep expressing yourself!\n",
  "wordCount" : "1982",
  "inLanguage": "en",
  "datePublished": "2019-03-24T00:00:00+03:00",
  "dateModified": "2019-03-24T00:00:00+03:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://smyachenkov.com/posts/categorizing-instagram-tags-with-k-means/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Stanislav Myachenkov",
    "logo": {
      "@type": "ImageObject",
      "url": "https://smyachenkov.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://smyachenkov.com/" accesskey="h" title="Stanislav Myachenkov (Alt + H)">Stanislav Myachenkov</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://smyachenkov.com/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://smyachenkov.com/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://smyachenkov.com/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://smyachenkov.com/index.xml" title="RSS Feed">
                    <span>RSS Feed</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Categorizing Instagram Tags with K-Means
    </h1>
    <div class="post-meta"><span title='2019-03-24 00:00:00 +0300 +03'>March 24, 2019</span>&nbsp;·&nbsp;10 min

</div>
  </header> 
  <div class="post-content"><p>Over the last couple of years Instagram, Facebook and many other social media have gotten rid of the chronological order in their post feed. While frustrating at first, this decision encouraged one part of social media that I like most of all: your content can be seen, discovered and rated not only by your friends and followers, but also by many other new people. To make your content discoverable you can use features such as hashtags, geolocations, tagging other people and so on.</p>
<p>In this article I will show you how to choose hashtags for your posts using machine learning to make it searchable for as many people interested in similar posts as possible. To solve this problem I will try to separate a dataset of Instagram hashtags from different users by their categories, so we can always have a good selection of hashtags on our hands. Ideally we will end up with a set of categories specific enough to fit  your particular post, for example, about minimalistic architecture photography in Morocco or skydiving in New Zealand.</p>
<h2 id="perfect-tag">Perfect tag<a hidden class="anchor" aria-hidden="true" href="#perfect-tag">#</a></h2>
<p>In order to choose effective hashtags you have to balance two things.</p>
<p>First, your tags should not be overused, because otherwise your may easily get lost in millions of other posts. For example, hashtags such as <a href="https://www.instagram.com/explore/tags/travel/"><!-- raw HTML omitted -->#travel<!-- raw HTML omitted --></a> with 380m posts and <a href="https://www.instagram.com/explore/tags/photooftheday/"><!-- raw HTML omitted -->#photooftheday<!-- raw HTML omitted --></a> with 644m at the moment are simply too popular making it quite hard to compete for the top places</p>
<p>Second, your tags must be popular enough in their category; there must be people who watch and update them with new posts daily. Let&rsquo;s say, our lowest boundary for tag popularity will be 100k posts and the highest will be 10m. Those numbers are purely objective: I got them from my friends who are active Instagram users. The data may be not perfect, but it&rsquo;s good enough for the first iteration.</p>
<p>In addition to all that numeric criteria, your tag must be related to your post and your post category, simply because users want to discover related content.</p>
<p>To keep it short, our perfect tag must:<br>
• Be specific enough<br>
• Have between 100k and 10m posts<br>
• Belong to some group(s)</p>
<h2 id="our-goal">Our Goal<a hidden class="anchor" aria-hidden="true" href="#our-goal">#</a></h2>
<p>We are going to implement a categorization system, that will take tags like <!-- raw HTML omitted -->#building<!-- raw HTML omitted -->, <!-- raw HTML omitted -->#skyscaper<!-- raw HTML omitted -->, <!-- raw HTML omitted -->#architecturelovers<!-- raw HTML omitted --> and <!-- raw HTML omitted -->#architectureporn<!-- raw HTML omitted --> and put them in a category that we will later call <strong>Architecture</strong>, or put tags like <!-- raw HTML omitted -->#pizza<!-- raw HTML omitted -->, <!-- raw HTML omitted -->#pasta<!-- raw HTML omitted --> and <!-- raw HTML omitted -->#italy<!-- raw HTML omitted --> in another category that can be called <strong>Italian Food</strong>.</p>
<p>To accomplish this, we are going to to collect a large number of Instagram posts, extract tags from them, and divide those tags into categories. You may ask, where are we going to find a list of the categories? Here&rsquo;s the beauty of machine learning algorithms: we don&rsquo;t know right now and that&rsquo;s fine! However, using a few techniques and algorithms, we can separate a huge number of tags into small groups.</p>
<p>That&rsquo;s is how <strong>Unsupervised Learning</strong> works.</p>
<p>In machine learning there are two huge areas: <a href="https://wikipedia.org/wiki/Supervised_learning">supervised learning</a> and <a href="https://en.wikipedia.org/wiki/Unsupervised_learning">unsupervised learning</a>. The main goal of supervised machine learning is to determine if new data belongs to one of the already known groups, while unsupervised learning separates data into new categories, that were unknown before.</p>
<p>We will be using one of the most popular unsupervised machine learning algorithms —  <a href="https://wikipedia.org/wiki/K-means_clustering"><strong>k-means</strong></a>.</p>
<h2 id="dataset">Dataset<a hidden class="anchor" aria-hidden="true" href="#dataset">#</a></h2>
<p>Our dataset consist of sets of hashtags, one for each instagram post. A single post may contain from 0 to 30 hashtags.</p>
<p>Here&rsquo;s the distribution of tags in my dataset:</p>
<p><img loading="lazy" src="/images/1_categorizing-instagram-tags-with-k-means/tag_count_distribution.png" alt="Tag distribution"  />
</p>
<p>From this data, we can already make some quick assumptions. The two most popular numbers of hashtags are 1 and 30. It means that there are two broad categories of users: the first category assigns one meaningfull tag without spending lots of time on choosing more popular tags, and the other milks the hashtag machine for every possible opportunity :)</p>
<p>Posts without any tags are excluded from this dataset because they don&rsquo;t provide anything for our task.</p>
<p>We don&rsquo;t need any other information from posts except their tags: we don&rsquo;t care about the author, location or number of likes. Our input data will be a list of arrays of tags, where each line represents one single post:</p>
<pre tabindex="0"><code>. . .
{artofvisual,instamoment,spain,photo,andalucia,instalike,igersspain}
{artofvisual,photos,nature,andalucia,instamoment,pic,spain,seville}
{picture,exposure,instalike,photoftheday,igers,spain,picoftheday}
{instamoment,picoftheday,photoftheday,picture,exploreeverything,igers}
{christmas,photoftheday,picoftheday,moment,pic,igers}
{ramennoodles,ramen,vegan,veganfood,whatveganseat,berlin,japanese,weekend}
{summer,frozenyogurt,oreo,mango,blueberry}
{photography,see,love,pic,mountains,view,picture,mood,dream,day,nature,pictureoftheday}
{autumn,tofu,instadaily,whatveganseat,lunch,vegan,pumpkin}
{hamburger,manhattan,fries,vegan,downtown,vacation,nyc}
{naturewalk,zipline,archery,sunset,cycling,hiking,kenya}
{sunsetlover,sunset,lovephotography,mobilephotography,sunsetsky,mobileclick,visionofpictures}
{flowers,shadow,simplicity,spring,minimalism,home,nature,sunny,weekend,tulips,morning,still,mood}
. . .
</code></pre><h2 id="measuring-tf-idf-for-tags">Measuring tf-idf for tags<a hidden class="anchor" aria-hidden="true" href="#measuring-tf-idf-for-tags">#</a></h2>
<p>We are going to place our posts into a multi-dimensional space, where each dimension represents one hashtag. It will be a very sparse space, because each post contains maximum of 30 tags, which means there will be 30 non-zero coordinate values, while all other coordinates, a couple of thousand of them, will be zero.</p>
<p>At this point, let&rsquo;s do the whole process on a small sample dataset of 6 posts about Italian food and architecture:</p>
<pre tabindex="0"><code>0: {italy,food}
1: {food,italy}
2: {food}
3: {italy,architecture}
4: {architecture,italy}
5: {architecture, }
</code></pre><p>As you can see, this dataset has 3 unique hashtags: <!-- raw HTML omitted -->#italy<!-- raw HTML omitted -->, <!-- raw HTML omitted -->#food<!-- raw HTML omitted -->, and <!-- raw HTML omitted -->#architecture<!-- raw HTML omitted -->. That means we are going to be dealing with a 3-dimensional space.</p>
<p><img loading="lazy" src="/images/1_categorizing-instagram-tags-with-k-means/plot_1_empty.png" alt="Empty tag dimension"  />
</p>
<p>Now we need to put our posts into this 3-D tag space. We will calculate dimension values for every post using <a href="https://wikipedia.org/wiki/Tf%E2%80%93idf"><strong>td-idf</strong></a> metric. This metric shows how important a word is in a document, in our case it measures the impact of a single tag for a post. It means that tags with very low or very high frequency will be assigned a lower rank.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>vectorizer <span style="color:#f92672">=</span> TfidfVectorizer()
</span></span><span style="display:flex;"><span>posts_coordinates <span style="color:#f92672">=</span> vectorizer<span style="color:#f92672">.</span>fit_transform(posts)	
</span></span><span style="display:flex;"><span>print(posts_coordinates)
</span></span></code></pre></div><table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody>
<tr>
<td>architecture</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0.75</td>
<td>0.75</td>
<td>1.0</td>
</tr>
<tr>
<td>food</td>
<td>0.75</td>
<td>0.75</td>
<td>1.0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>italy</td>
<td>0.65</td>
<td>0.65</td>
<td>0</td>
<td>0.65</td>
<td>0.65</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><img loading="lazy" src="/images/1_categorizing-instagram-tags-with-k-means/plot_2_tags.png" alt="Posts in 3d space"  />
</p>
<p>Posts 0 and 1 contain exactly the same set of tags, so they have exactly the same coordinates and they are placed in the same position in our tag space. Same goes for posts 3 and 4; the order of tags doesn&rsquo;t matter.</p>
<p>This will be our data for following clustering with k-means.</p>
<h2 id="applying-k-means">Applying K-Means<a hidden class="anchor" aria-hidden="true" href="#applying-k-means">#</a></h2>
<p><a href="https://wikipedia.org/wiki/K-means_clustering">K-Means</a> is one of the most popular clustering algorithms and it&rsquo;s pretty simple. The only decision you have to make is the number of clusters you want your data to be divided into — <em>k</em> number. The goal of this algorithm is to determine coordinates of <em>k</em> points, which will be the centers of mass for a cluster. Those points are also called <em>centroids</em>.</p>
<p>The algorithm has 3 steps:</p>
<ol>
<li>Initialize <em>k</em> cenrtoids with random coordinates</li>
<li>Divide all training examples into <em>k</em> groups by choosing the nearest centroid</li>
<li>Assign new centroid coordinates by calculating a center of mass for the groups from step 2</li>
</ol>
<p>Steps 2 and 3 are repeated until the algorithm converges or reaches an optimal state. Results may depend a lot on randomly chosen initial centroid values, so calculcations can be run multiple times to get rid of random impact.</p>
<p>Let&rsquo;s see how it works on the example.</p>
<ol>
<li>In this image the gray squares are training examples and the colored circles are initial centroids. All the centroids are initialized with random coordinates, the training examples are not clustered.<br>
<img loading="lazy" src="/images/1_categorizing-instagram-tags-with-k-means/K_Means_Example_Step_1.svg" alt="K-Means step 1"  />
</li>
</ol>
<!-- raw HTML omitted -->
<ol start="2">
<li>Here all the training examples are assigned to the closest centroid and marked with the centroid&rsquo;s color<br>
<img loading="lazy" src="/images/1_categorizing-instagram-tags-with-k-means/K_Means_Example_Step_2.svg" alt="K-Means step 2"  />
</li>
</ol>
<!-- raw HTML omitted -->
<ol start="3">
<li>Now we need to calculate new centroids for the groups created in step 2. This is achieved by calculating centers of mass for each training example belonging to a group<br>
<img loading="lazy" src="/images/1_categorizing-instagram-tags-with-k-means/K_Means_Example_Step_3.svg" alt="K-Means step 3"  />
</li>
</ol>
<!-- raw HTML omitted -->
<ol start="4">
<li>Clusterization by distance from newly created centroid is repeated and if we see that there are no more iterations required we can stop the algorithm and call this clusterization final<br>
<img loading="lazy" src="/images/1_categorizing-instagram-tags-with-k-means/K_Means_Example_Step_4.svg" alt="K-Means step 4"  />
</li>
</ol>
<!-- raw HTML omitted -->
<p>Now we are going to apply k-means clusterization to our dataset of posts about Italy. By looking at it, we can tell that there are 2 groups: food and architecture. So our <em>k</em>-parameter(the number of clusters we are going to divide our group into) will be 2.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>KMEANS_CLUSTERS <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>model <span style="color:#f92672">=</span> KMeans(
</span></span><span style="display:flex;"><span>    n_clusters<span style="color:#f92672">=</span>KMEANS_CLUSTERS,
</span></span><span style="display:flex;"><span>    init<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;k-means++&#39;</span>,
</span></span><span style="display:flex;"><span>    max_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span>,
</span></span><span style="display:flex;"><span>    n_init<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    verbose<span style="color:#f92672">=</span><span style="color:#66d9ef">True</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>groups <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>fit_predict(data)
</span></span></code></pre></div><p><code>groups</code> is an array with the same size as the initial <code>data</code> array — 6. And it contains groups ids for entries in <code>data</code> in the same order:</p>
<pre tabindex="0"><code>post 0: 0
post 1: 0
post 2: 0
post 3: 1
post 4: 1
post 5: 1
</code></pre><p>Our dataset was successfully divided into two groups: 0 —  &ldquo;food&rdquo; and 1 —  &ldquo;architecture&rdquo;.</p>
<h2 id="extracting-tags-for-categories">Extracting Tags For Categories<a hidden class="anchor" aria-hidden="true" href="#extracting-tags-for-categories">#</a></h2>
<p>Lets see where the centroids are located.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>centroids <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>cluster_centers_
</span></span></code></pre></div><p><code>centroids</code> are represented by a 2x3 matrix where each row contains the coordinates of a centroid in 3-dimensional space. Let&rsquo;s add them to our plot.</p>
<table>
<thead>
<tr>
<th></th>
<th>architecture</th>
<th>food</th>
<th>italy</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0.84</td>
<td>0.43</td>
</tr>
<tr>
<td>1</td>
<td>0.84</td>
<td>0</td>
<td>0.43</td>
</tr>
</tbody>
</table>
<p><img loading="lazy" src="/images/1_categorizing-instagram-tags-with-k-means/plot_3_kmeans.png" alt="K-Means centroids"  />
</p>
<p>Our categories are located in the same 3-dimendional space as the posts from our training example. It means that each category has some numeric value that represents its relations to tags - coordinates. If we take absolute values of coordinates and sort them in ascending order - from highest to lowest - we can find tags with most impact on this particular category: it will be tags with lowest value, the closest to a category.</p>
<p>For instance, the most meaningful tag for our first centroid(on the right in the picture) is <!-- raw HTML omitted -->#architecture<!-- raw HTML omitted -->, and for the second centroid(on the left in the picture) it&rsquo;s <!-- raw HTML omitted -->#food<!-- raw HTML omitted -->.</p>
<p>Imagine that we have many more tags, let&rsquo;s say 10,000. We would not be interested in all 10,000 relations for each category, we would only want the most meaningful tags. So we will limit the top tags for each category by some number and only show those ones. This number will depend on how many clusters we choose.</p>
<p>Let&rsquo;s get back to our example. We are going to limit the number of tags in each category by two and pick the two most meaningful tags.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>TAGS_IN_CATEGORY <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>ordered_centroids <span style="color:#f92672">=</span> model<span style="color:#f92672">.</span>cluster_centers_<span style="color:#f92672">.</span>argsort()[:, ::<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>]	
</span></span><span style="display:flex;"><span>tags <span style="color:#f92672">=</span> vectorizer<span style="color:#f92672">.</span>get_feature_names()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> idx, centroids <span style="color:#f92672">in</span> enumerate(ordered_centroids):
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Centroid </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">:&#34;</span> <span style="color:#f92672">%</span> idx)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> centroid_tag <span style="color:#f92672">in</span> centroids[:TAGS_IN_CATEGORY]:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;#</span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> tags[centroid_tag])
</span></span></code></pre></div><p>This code separeates our tags into two categories:</p>
<pre tabindex="0"><code>Centroid 0:
#architecture
#italy
Centroid 1:
#food
#italy
</code></pre><p>Here, tags in the category are ordered from the most relevant to the least. If we take some tags from the top of every category, we&rsquo;ll get tags that can represent this category in a shorter way than listing all of them. Let&rsquo;s call them <em>leading tags</em>. Like if we were to choose the one leading tag from our categories, we would get <!-- raw HTML omitted -->#architecture<!-- raw HTML omitted --> and <!-- raw HTML omitted -->#food<!-- raw HTML omitted -->.</p>
<p>Let&rsquo;s try this approach using a bigger sample. Imagine we have a classifier that produces tag categories with 20 tags, and one of the categories looks like this:</p>
<pre tabindex="0"><code>#boat
#water
#sailing
#ocean
#lake
#ship
#river
#boatlife
#boats
#port
#island
#sail
#yacht
#vacation
#reflection
#sailboat
#fishing
#bateau
#relax
#boating
</code></pre><p>This group clearly combines tags related to boats and sailing. We can give it a human-readable name using its leading tags. Let&rsquo;s say we want to have 3 leading tags, then they will be <!-- raw HTML omitted -->#boat<!-- raw HTML omitted -->, <!-- raw HTML omitted -->#water<!-- raw HTML omitted --> and <!-- raw HTML omitted -->#sailing<!-- raw HTML omitted -->. In the next step, we will concatenate these tags into a single name so it will look like <strong>boat_water_sailing</strong>.</p>
<p>While working on a large dataset, we will end up with a huge list of categories named like this one, or, for example, something like <strong>animal_animals_cat</strong>, <strong>goodmorning_coffee_morning</strong> or <strong>sushi_japanesefood_food</strong>.
These human-readable names can help us quickly understand what this group is about and implement a groups catalogue, search or group suggestions.</p>
<h2 id="result">Result<a hidden class="anchor" aria-hidden="true" href="#result">#</a></h2>
<p>In this article we&rsquo;ve explored a way of grouping Instagram tags from a set of Instagram posts into thematic categories.</p>
<p>You can find a working demo here: <a href="https://github.com/smyachenkov/k-means_tags_demo">https://github.com/smyachenkov/k-means_tags_demo</a>.</p>
<p>I left behind some topics, for example, choosing k-means parameters like number of categories and number of tags in a single category. I will cover those topics in my upcoming posts.</p>
<p>In conclusion, I want to say that exploring new content can be very fun, and some categories have a huge amount of awesome content. You can use this knowledge to find interesting new people, find your unique style, place your content into the right category or be inspired by something new.</p>
<p>Keep expressing yourself!</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://smyachenkov.com/tags/machine-learning/">machine learning</a></li>
      <li><a href="https://smyachenkov.com/tags/categorization/">categorization</a></li>
      <li><a href="https://smyachenkov.com/tags/k-means/">k-means</a></li>
      <li><a href="https://smyachenkov.com/tags/instagram/">instagram</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://smyachenkov.com/posts/number-of-categories-for-k-means/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Number of Categories for K-Means: Elbow and Silhouette Methods</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Categorizing Instagram Tags with K-Means on twitter"
        href="https://twitter.com/intent/tweet/?text=Categorizing%20Instagram%20Tags%20with%20K-Means&amp;url=https%3a%2f%2fsmyachenkov.com%2fposts%2fcategorizing-instagram-tags-with-k-means%2f&amp;hashtags=machinelearning%2ccategorization%2ck-means%2cinstagram">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Categorizing Instagram Tags with K-Means on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsmyachenkov.com%2fposts%2fcategorizing-instagram-tags-with-k-means%2f&amp;title=Categorizing%20Instagram%20Tags%20with%20K-Means&amp;summary=Categorizing%20Instagram%20Tags%20with%20K-Means&amp;source=https%3a%2f%2fsmyachenkov.com%2fposts%2fcategorizing-instagram-tags-with-k-means%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Categorizing Instagram Tags with K-Means on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fsmyachenkov.com%2fposts%2fcategorizing-instagram-tags-with-k-means%2f&title=Categorizing%20Instagram%20Tags%20with%20K-Means">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Categorizing Instagram Tags with K-Means on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsmyachenkov.com%2fposts%2fcategorizing-instagram-tags-with-k-means%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Categorizing Instagram Tags with K-Means on whatsapp"
        href="https://api.whatsapp.com/send?text=Categorizing%20Instagram%20Tags%20with%20K-Means%20-%20https%3a%2f%2fsmyachenkov.com%2fposts%2fcategorizing-instagram-tags-with-k-means%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Categorizing Instagram Tags with K-Means on telegram"
        href="https://telegram.me/share/url?text=Categorizing%20Instagram%20Tags%20with%20K-Means&amp;url=https%3a%2f%2fsmyachenkov.com%2fposts%2fcategorizing-instagram-tags-with-k-means%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://smyachenkov.com/">Stanislav Myachenkov</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
